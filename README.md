# dynamic-corrupted-file
After a file compression failure, all the white space among words in a text file was lost. Write a C++ program which utilizes dynamic programming to get all of the possible original documents (i.e. with white spaces between words) and ranks them in order of likelihood; all in minimal time.

How it works: For the project, I implemented the 'sliding door' dynamic programming technique to find all acceptable possible sentences that can be made with a corrupted file, in which there are no spaces. The Program will start by building a trie data structure with a dictionary the user puts in. I made the following variation to the trie:
- Adding a isInWord() function that returns if a string(built one letter at a time) is within a word, but not a word itself. This is useful to ensure we are going down the right path, and are not trying to add letters onto a word that does not exist. When this is false, we are confident that no variation exists with the previously constructed sentence. 
- Modified the trie to store the values of given words in the order of which they are added. Added an int to the struct that keeps track of the order in which the word was placed into the trie. This will occur at nodes in which the isEndOfWord boolean value is true, and is used for ranking the outcomes.

After this, the program finds all sentences. This function takes the root of the trie, the position, the window(string), the corrupted file, and the vector of answers, as the parameters. The string 'prev' will act as the sliding window in this dynamic programming technique. It starts by adding character by character to 'prev', each time checking if the string is within any word. If at any time 'prev' is not found within any word, the recursive instance will return without pushing anything onto the vector of possible sentences. When it does find a word, it will make a recursive call maintaining 'prev' to see if more words can be built without a space. In the original recursive instance, 'prev' is cleared and a space is added. This way, the instance in which a space was added is tested within the previous instance, and the instance in which no space is added is tested in the recursive call. The base case occurs when the program encounters the '*' which is added by the program to the input string. At this point, it will push the solution onto the vector of answers only if 'prev' is clear, which implies that it just ended on a word, or there was punctuation which is not added to 'prev'.

Finally to sort the possibilities, the punctuation is taken out, and they are searched and ranked via the ranked function which uses the value I included in the trie. The algorithm used is the sum of the totals divided by the number of words. By using the average to weight, there is no advantage or disadvantage to the number of words in a sentence. Ths score is modeled after the cross country scoring system, in which the rank is added to the score, and the team with the lowest rank wins. At the end, the console displays every single possible sentence, along with the average rank of all the words within it. This way not only can you see which sentence is more likely, but how much more likely it is. It will then ask you if you want to output the most likely solution to a file, which the user will provide.
